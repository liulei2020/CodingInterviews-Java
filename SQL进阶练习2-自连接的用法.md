# SQL进阶练习2-自连接的用法

## 可重排列，排列，组合

原数据：

| name | price |
| ---- | ----- |
| 橘子 | 100   |
| 苹果 | 50    |
| 香蕉 | 80    |

```sql
-- 用于获取可重排列的SQL语句
SELECT
	P1.NAME AS name_1,
	P2.NAME AS name_2 
FROM
	products P1,
	products P2;
```

结果：

| name_1 | name_2 |
| ------ | ------ |
| 香蕉   | 橘子   |
| 苹果   | 橘子   |
| 橘子   | 橘子   |
| 香蕉   | 苹果   |
| 苹果   | 苹果   |
| 橘子   | 苹果   |
| 香蕉   | 香蕉   |
| 苹果   | 香蕉   |
| 橘子   | 香蕉   |

执行结果里每一行（记录）都是一个有序对。因为是可重排列，所以结果行数为3^2^  = 9

首先，为了去掉（苹果，苹果）这种由相同元素构成的对，需要像下面这样加上一个条件，然后再进行连接运算。

```sql
-- 用于获取排列的 SQL语句
SELECT
	P1.NAME AS name_1,
	P2.NAME AS name_2 
FROM
	Products P1,
	Products P2 
WHERE
	P1.NAME <> P2.NAME;
```

结果：

| name_1 | name_2 |
| ------ | ------ |
| 香蕉   | 橘子   |
| 苹果   | 橘子   |
| 香蕉   | 苹果   |
| 橘子   | 苹果   |
| 苹果   | 香蕉   |
| 橘子   | 香蕉   |

加上WHERE P1.name <> P2.name这个条件以后，就能排除掉由相同元素构成的对，结果行数为排列P^2^~3~＝6。

当然，无论是P1还是P2，实际上数据都来自同一张物理表Products。但是，在SQL里，只要被赋予了不同的名称，即便是相同的表也应该当作不同的表（集合）来对待。也就是说，P1和P2可以看成是碰巧存储了相同数据的两个集合。

接下来我们进一步对（苹果，橘子）和（橘子，苹果）这样只是调换了元素顺序的对进行去重。

```sql
-- 用于获取组合的SQL语句
SELECT
	P1.NAME AS name_1,
	P2.NAME AS name_2 
FROM
	Products P1,
	Products P2 
WHERE
	P1.NAME > P2.NAME;
```

结果：

| name_1 | name_2 |
| ------ | ------ |
| 香蕉   | 橘子   |
| 苹果   | 橘子   |
| 香蕉   | 苹果   |

同样地，请想象这里存在P1和P2两张表。在加上“大于”这个条件后，这条SQL语句所做的是，按字符顺序排列各商品，只与“字符顺序比自己靠前”的商品进行配对，结果行数为组合C^2^~3~＝3。得到了无序对。平时说到组合，就是这种类型的组合。

想要获取3个以上元素的组合时，像下面这样简单地扩展一下就可以了。这次的样本数据只有3行，所以结果应该只有1行。

```sql
-- 用于获取组合的SQL语句：扩展成3列
SELECT
	P1.NAME AS name_1,
	P2.NAME AS name_2,
	P3.NAME AS name_3 
FROM
	Products P1,
	Products P2,
	Products P3 
WHERE
	P1.NAME > P2.NAME 
```

结果：

| name_1 | name_2 | name_3 |
| ------ | ------ | ------ |
| 香蕉   | 苹果   | 橘子   |

使用等号“＝”以外的比较运算符，如“<、>、<>”进行的连接称为“非等值连接”。这里将非等值连接与自连接结合使用了，称为“非等值自连接”。在需要获取列的组合时，经常需要用到这个技术，请牢记。最后补充一点“, >”和“<”等比较运算符不仅可以用于比较数值大小，也可以用于比较字符串（比如按字典序进行比较）或者日期等。

## 删除重复行

使用关联子查询删除重复行的方法。

连接和关联子查询虽然是不同的运算，但是思路很像，而且很多时候它们的SQL在功能上是等价的。

![image-20230302102535087](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230302102535087.png)

在下面的SQL语句里，我们使用的是Oracle数据库里的rowid。

```sql
    -- 用于删除重复行的SQL语句(1)：使用极值函数
    DELETE FROM Products P1
     WHERE rowid < ( SELECT MAX(P2.rowid)
                      FROM Products P2
                      WHERE P1.name = P2. name
                        AND P1.price = P2.price ) ;
```

这个关联子查询的处理看起来不是很好理解。本来，关联子查询正如其名，就是用来查找两张表之间的关联性的，而这里只有一张表，却也跟“关联”扯上了关系，想必大家都心存疑问吧。

之所以大家会有这种疑问，是因为没有从正确的层面来理解这条SQL语句。像前面的例题里讲过的一样，将关联子查询理解成对两个拥有相同数据的集合进行的关联操作。

对于在SQL语句里被赋予不同名称的集合，我们应该将其看作完全不同的集合。

这个子查询会比较两个集合P1和P2，然后返回商品名称和价格都相同的行里最大的rowid所在的行。

于是，由于苹果和香蕉没有重复行，所以返回的行是“1：苹果”  “5：香蕉”，而判断条件是小于号，所以该行不会被删除。而对于“橘子”这个商品，程序返回的行是“4：橘子”，那么rowid比4小的两行——“2：橘子”和“3：橘子”都会被删除。

通过这道例题我们明白，如果从物理表的层面来理解SQL语句，抽象度是非常低的。**“表”“视图”这样的名称只反映了不同的存储方法**，而存储方法并不会影响到SQL语句的执行和结果，因此无需有什么顾虑（在不考虑性能的前提下）。**无论表还是视图，本质上都是集合——集合是SQL能处理的唯一的数据结构**。

此外，用前面介绍过的非等值连接的方法也可以写出与这里的执行过程一样的SQL语句。

```sql
-- 用于删除重复行的SQL语句(2)：使用非等值连接
DELETE FROM Products P1 
WHERE
	EXISTS (
	SELECT * 
	FROM Products P2 
	WHERE
		P1.NAME = P2.NAME 
		AND P1.price = P2.price 
	   AND P1.rowid < P2.rowid 
	);
```

## 查找局部不一致的列

```sql
-- 用于查找价格相等但商品名称不同的记录的SQL语句
SELECT DISTINCT
	P1.NAME,
	P1.price 
FROM
	Products P1,
	Products P2 
WHERE
	P1.price = P2.price 
	AND P1.NAME <> P2.NAME;
```

如果不加上DISTINCT，结果里就会出现重复行。关键在于价格相同的记录的条数。这道例题使用的是连接查询，如果改用关联子查询，就不需要DISTINCT了。

## 排序

某些数据库管理系统（Database Management System, DBMS）已经实现了这样的功能（如Oracle、DB2数据库的RANK函数等）。现在，我们要按照价格从高到低的顺序，对下面这张表里的商品进行排序。我们让价格相同的商品位次也一样，而紧接着它们的商品则有两种排序方法，一种是跳过之后的位次，另一种是不跳过之后的位次。

| name | price |
| ---- | ----- |
| 橘子 | 100   |
| 苹果 | 50    |
| 香蕉 | 80    |
| 西瓜 | 80    |
| 柠檬 | 30    |
| 葡萄 | 50    |

如果使用窗口函数，可以像下面这样实现。

```sql
-- 排序：使用窗口函数
SELECT 
	NAME,
	price,
	RANK() OVER ( ORDER BY price DESC ) AS rank_1,
	DENSE_RANK() OVER ( ORDER BY price DESC ) AS rank_2 
FROM
	Products;
```

结果：

| NAME | price | rank_1 | rank_2 |
| ---- | ----- | ------ | ------ |
| 橘子 | 100   | 1      | 1      |
| 西瓜 | 80    | 2      | 2      |
| 苹果 | 50    | 3      | 3      |
| 葡萄 | 50    | 3      | 3      |
| 香蕉 | 50    | 3      | 3      |
| 柠檬 | 30    | 6      | 4      |

在出现相同位次后，rank_1跳过了之后的位次，rank_2没有跳过，而是连续排序。

有没有不依赖于具体数据库来实现的方法。下面是用非等值自连接（真的很常用）写的代码。

```sql
-- 排序从1开始。如果已出现相同位次，则跳过之后的位次
SELECT
	P1.NAME,
	P1.price,
	( SELECT COUNT( P2.price ) FROM Products P2 WHERE P2.price > P1.price ) + 1 AS rank_1 
FROM
	Products P1 
ORDER BY
	rank_1;
```

结果：

| NAME | price | rank_1 |
| ---- | ----- | ------ |
| 橘子 | 100   | 1      |
| 西瓜 | 80    | 2      |
| 苹果 | 50    | 3      |
| 葡萄 | 50    | 3      |
| 香蕉 | 50    | 3      |
| 柠檬 | 30    | 6      |

这段代码的排序方法看起来很普通，但很容易扩展。

例如去掉标量子查询后边的+1，就可以从0开始给商品排序，而且如果修改成COUNT(DISTINCT P2.price)，那么存在相同位次的记录时，就可以不跳过之后的位次，而是连续输出（相当于DENSE_RANK函数）。

由此可知，这条SQL语句可以根据不同的需求灵活地进行扩展，实现不同的排序方式。

这条SQL语句的执行原理。这道例题很好地体现了面向集合的思维方式。

子查询所做的，是计算出价格比自己高的记录的条数并将其作为自己的位次。为了便于理解，我们先考虑从0开始，对去重之后的4个价格“{ 100, 80, 50, 30 }”进行排序的情况。

首先是价格最高的100，因为不存在比它高的价格，所以COUNT函数返回0。接下来是价格第二高的80，比它高的价格有一个100，所以COUNT函数返回1。同样地，价格为50的时候返回2，为30的时候返回3。这样，就生成了一个与每个价格对应的集合，如下表所示。

同心圆状的递归集合

| 集合 | 价格 | 比自己高的价格 | 比自己高的价格的个数（这就是位次） |
| ---- | ---- | -------------- | ---------------------------------- |
| S0   | 100  | —              | 0                                  |
| S1   | 80   | 100            | 1                                  |
| S2   | 50   | 100,80         | 2                                  |
| S3   | 30   | 100,80,50      | 3                                  |

实际上，“通过递归集合来定义数”这个想法并不算新颖。有趣的是，它和集合论里沿用了100多年的自然数（包含0）的递归定义（recursive definition）在思想上不谋而合[插图]。研究这种思想的学者形成了几个流派，其中和这道例题的思路类型相同的是计算机之父、数学家冯·诺依曼提出的想法。冯·诺依曼首先将空集定义为0，然后按照下面的规则定义了全体自然数。

0 = 空集

1 = {0}

2 = {0,1}

3 = {0,1,2}

......

定义完0之后，用0来定义1，然后用0和1来定义2，再用0、1和2来定义3……以此类推。

这道题很好地直接结合了SQL和集合论，而联系二者的正是自连接。

顺便说一下，这个子查询的代码还可以像下面这样按照自连接的写法来改写。

```sql
-- 排序：使用自连接
SELECT
	P1.NAME,
	MAX( P1.price ) AS price,
	COUNT( P2.NAME ) + 1 AS rank_1 
FROM
	Products P1
	LEFT OUTER JOIN Products P2 ON P1.price < P2.price 
GROUP BY
	P1.NAME 
ORDER BY
	rank_1;
```

运行结果：

| NAME | price | rank_1 |
| ---- | ----- | ------ |
| 橘子 | 100   | 1      |
| 西瓜 | 80    | 2      |
| 苹果 | 50    | 3      |
| 葡萄 | 50    | 3      |
| 香蕉 | 50    | 3      |
| 柠檬 | 30    | 6      |

## 小结

通过4个应用实例学习了自连接的一些知识。

自连接是不亚于CASE表达式的重要技术，**请一定熟练掌握**。最后说一个需要注意的地方，与多表之间进行的普通连接相比，**自连接的性能开销更大（特别是与非等值连接结合使用的时候）**，因此**用于自连接的列推荐使用主键或者在相关列上建立索引**。本节例题里出现的连接大多使用的是主键。

本节要点。

1．自连接经常和非等值连接结合起来使用。

2．自连接和GROUP BY结合使用可以生成递归集合。

3．将自连接看作不同表之间的连接更容易理解。

4．应把表看作行的集合，用面向集合的方法来思考。

5．自连接的性能开销更大，应尽量给用于连接的列建立索引。

